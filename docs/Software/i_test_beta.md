---
layout: default
permalink: /notes/betadiagnostics
title: Beta CPU Diagnostics
description: Diagnose faults in Beta CPU Datapath
nav_order: 10
parent: Software Related Topics
---

* TOC
{:toc}

**50.002 Computation Structures**
<br>
Information Systems Technology and Design
<br>
Singapore University of Technology and Design


# Beta CPU Diagnostics
{: .no-toc} 

In this chapter, we'll focus on understanding and fixing problems in the Beta CPU, specifically looking at its datapath. We'll learn how to find out which datapath might be faulty using simple testing software to spot these issues, and figure out what code changes can help when parts of the system aren't working correctly. Our goal is about getting to know the Beta CPU datapath better and being able to fix it whenever possible. We will also learn how to handle **exceptions**, **trap**, and **interrupts**. 


## [Interrupt Handling](https://www.youtube.com/watch?v=4T9MR8BSzt0&t=4563s)

**Interrupts**; as the name suggests is a response initiated by the CPU when an *error* or out-of-the-ordinary event occurs. 

$$\beta$$ exceptions come in **two** broad categories: **synchronous** and **asynchronous** interrupts. The key difference lies in their **timing** and **source**. 


1. **Synchronous Interrupts**: Interrupts that are generated by the CPU itself as a result of executing an instruction. They're also called software interrupts in some books. There are two types of synchronous interrupts:
   a. **System Calls (Traps)**: A system call is a mechanism used by an application program to request service from the operating system. When a system call is made, the CPU switches to kernel mode to execute the operating system's code. This is often referred to as a "trap," as the application is effectively trapping into the operating system.
   b. **Exceptions**: Exceptions are a type of exception raised by the CPU in response to error conditions, like a division by zero, invalid memory access, or other illegal operations. When a fault occurs, the CPU switches to kernel mode to handle the error, potentially terminating the offending process or taking other corrective actions.
2. **Asynchronous Interrupts**: These are interrupt signals that come from outside the CPU's current execution stream (not synchronysed with CPU clock). They are not directly tied to the execution of the current instruction sequence. These are signals sent to the processor from external devices, like a mouse or keyboard. When the CPU receives an interrupt, it temporarily halts the current execution thread, saves its state, and switches to kernel mode to handle the interrupt. After handling the interrupt, the CPU can return to the previous state and continue execution.


{: .note-title}
> Take it Easy
> 
> We will learn about this more in the final weeks of 50.002 and in 50.005. 

### Sampling the IRQ Signal
Notice the presence of the 1-bit register that **samples** the IRQ signal. This is  because. the IRQ signal actually an **asynchronous** interrupt trigger. In the later weeks, we will learn that **asynchronous** interrupts are generated by **other hardware devices** at *arbitrary* times with respect to the CPU clock signals. Therefore, we need another sequential logic device to **condition/synchronize** it such that it doesn't cause unwanted changes to the Control Unit in the middle of execution (in the middle of a clock cycle).  

This sampling device that receives the external `IRQ` signal allows the CPU to **sample** the input IRQ signal during the beginning of each instruction cycle, and will respond to the trigger only if the signal `IRQ` is asserted when sampling occurs.

The presence of the `CLK` signal in the Beta Datapath is written to remind you that the CPU should be able to *sample* the asynchronous `IRQ` signal  for each clock cycle. However, the heart of the Control Unit itself is combinational logic device (e.g: ROM) and not a sequential one.

### Synchronous Interrupts: Traps and Faults
**Traps** (*intentional*) and **faults** (*unintentional*) falls under the category of **software interrupts** and is **synchronous** with the CPU clk cycle. They are both the outcome of executing illegal instructions and it is **synchronous** with the CPU CLK cycle. These happens for example when we supply an illegal `OPCODE`, i.e: it does not correspond to any of the instructions defined in the ISA. The difference between the two are subtle: **traps** are intentional while **faults** are not.

The datapath that handles **trap/fault** (due to Illegal `OPCODE`) is as follows:
<img src="/50002/assets/contentimage/beta/illop.png"  class="center_seventy"/>

### Asynchronous Interrupts: Hardware Interrupts
Hardware Interrupts are **asynchronous** with the CPU CLK cycle. They're caused by other hardware connected to the system, for example from I/O devices like keyboard strokes or mouse presses. This would require us to "*pause*" the execution of the current program and **handle** the interrupt. 				
- At the beginning of each cycle, the CPU will always check whether `IRQ == 1`.  
- If `IRQ != 1`, the CPU will continue with normal execution. 
- If `IRQ == 1`, the CPU will *pause* the current execution and handle the interrupt request first (and eventually *resume* back the paused execution *after the interrupt handling is done*). 
 

The datapath that handles interrupt (due to asynchronous `IRQ` signal) is as follows:
<img src="/50002/assets/contentimage/beta/irq.png"  class="center_seventy"/>

### Differences in Datapath (simplified)
There's only **one** difference between the two types of interrupts (async vs sync): **the datapath at the PCSEL mux**. 
  
The PCSEL multiplexer's fourth and fifth input are called `ILLOP` and `XAdr`. In $$\beta$$ ISA,
-  `ILLOP` is set at `0x80000004`
-  `XAdr` is set at `0x80000008`

In this address resides the **entry point** of program that **handles** these events: illegal operation or hardware interrupts. 

### Control Signals for Interrupts
-  `ALUFN = --`
-  `WERF = 1`
- `BSEL = --`
-  `WDSEL = 00`
-  `WR = 0`
-  `RA2SEL = --`
-  `PCSEL`:
	-  `Illegal_Opcode ? 011 : 000`
	- `IRQ ? 100 : 000`
-  `ASEL = --` 
-  `WASEL = 1`

{: .note-title}
> Register XP (R30)
> 
> During exception, we set `WASEL = 1` and `WDSEL = 00` and `WERF = 1`. `PC+4` (supposed next instruction's address) is then **stored** at `Reg[XP]` (register 30, or `11110` in binary) so that we may **resume** the execution of this currently interrupted program once the exception has been **handled**. 




